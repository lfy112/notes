# 通用性能的提升

## 1. constexpr

### 1.1 constexpr

#### 1.1.1 const

以前只有`const`关键字时，有两个意义：**变量只读**、**修饰常量**

```c++
void func(const int num)
{
    const int count = 24;
    int array[num];            // error，num是一个只读变量，不是常量
    int array1[count];         // ok，count是一个常量

    int a1 = 520;
    int a2 = 250;
    const int& b = a1;
    b = a2;                         // error
    a1 = 1314;
    cout << "b: " << b << endl;     // 输出结果为1314
}
```

变量只读并不代表就是常量。

#### 1.1.2 constexpr

`constexpr`专门用来修饰常量，常量即在编译阶段就能得到计算结果的量。常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。

C++ 程序从编写完毕到执行分为四个阶段：**预处理、 编译、汇编和链接**4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序==运行阶段==计算出结果，但是常量表达式的计算往往发生在程序的==编译阶段==，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

在使用中建议将`const`和`constexpr`的功能区分开，即凡是表达“只读”语义的场景都使用`const`，表达“常量”语义的场景都使用`constexpr`。

对于 C++ 内置类型的数据，可以直接用`constexpr`修饰，但如果是自定义的数据类型（用`struct`或者`class`实现），直接用`constexpr`修饰是不行的。需要这样写：

```c++
struct Test
{
    int id;
    int num;
};
int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量
    t.num += 100;
    cout << "id: " << id << ", num: " << num << endl;

    return 0;
}
```

### 1.2 常量表达式函数

